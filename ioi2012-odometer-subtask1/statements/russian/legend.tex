\it{Эта задача содержит 5 подзадач. Технически они реализованы в виде 5 разных задач. У них один и тот же оператор, но тесты и чекер из соответствующей подзадачи. Вам нужно представить свои решения отдельно по ним. Для этой проблемы разрешен только язык одометра.}

Леонардо изобрел оригинальный одометр, представляющий собой тележку, которая может
измерять расстояния путем бросания камней в тех местах, где она повернулась. Посчитав
количество камней, мы получим количество поворотов колес тележки, которое позволит
пользователю вычислить расстояние, которое проехал одометр. Как настоящие
программисты, мы добавили программный контроль к одометру, расширив его
функциональность. Требуется написать программу, соответствующую заданным ниже
правилам.

\textbf{Рабочая поверхность}

Одометр перемещается по воображаемой квадратной сетке размером $256 \times 256$ клеток. В
каждой клетке не может находиться более $15$ камней. Каждая клетка задается парой
координат (строка, столбец), где каждая координата принадлежит диапазону от $0$ до $255$
включительно. Для клетки с координатами $(i, j)$ соседними являются клетки с
координатами $(i - 1, j)$, $(i + 1, j)$, $(i, j - 1)$ и $(i, j + 1)$, если они существуют. Клетки,
находящиеся на первой или последней строке или на первом или последнем столбце,
называются границей. Изначально одометр всегда находится в клетке с координатами $(0,
0)$ (северо-западный угол) и ориентирован на север.

\textbf{Основные команды}

Одометр может быть запрограммирован с помощью следующих команд.

\begin{itemize}
\item \texttt{left}~--- повернуться на $90$ градусов налево (против часовой стрелки) и остаться в
текущей клетке; например, если одометр был ориентирован на юг, то после
выполнения этой команды он будет ориентирован на восток.
\item \texttt{right}~--- повернуться на $90$ градусов вправо (по часовой стрелке) и остаться в
текущей клетке; например, если одометр был ориентирован на запад, то после
выполнения этой команды он будет ориентирован на север.
\item \texttt{move}~--- переместиться вперед, т.е в том направлении, в котором ориентирован
одометр, в соседнюю клетку. Если такой клетки нет (например, граница в
направлении ориентации одометра уже достигнута), то команда ничего не делает.
\item \texttt{get}~--- удалить один камень из текущей клетки. Если в текущей клетке нет камней,
то команда ничего не делает.
\item \texttt{put}~--- добавить один камень в текущую клетку. Если в текущей клетке уже есть $15$
камней, то команда ничего не делает. У одометра никогда не кончаются камни. 
\item \texttt{halt}~--- завершить выполнение программы.
\end{itemize}

Одометр выполняет команды в том порядке, в котором они заданы в программе.
Программа должна содержать не более одной команды в строке. Пустые строки
игнорируются. Символ \texttt{#} обозначает начало комментария; любой текст до конца строки
после него игнорируется. Если одометр достигает конца программы, выполнение
программы завершается.

\textbf{Пример 1}

Расотрим следующую программу для одометра. После её выполнения, одометр
оказывается ориентированным на восток в клетке $(0, 2)$. Обратите внимание, что первая
команда \texttt{move} будет проигнорирована, так как одометр находится в северо-западном углу
и ориентирован на север.

\begin{lstlisting}
move # не делает ничего
right
# сейчас одометр ориентирован на восток
move
move
\end{lstlisting} 

\textbf{Метки, границы и камни}

Для того, чтобы изменять порядок выполнения команд в зависимости от текущего
состояния, можно использовать метки. Метка это регистрозависимая строка, состоящая не
более чем из $128$ следующих символов: $a, \ldots, z, A, \ldots, Z, 0, \ldots, 9$. Новые команды для
работы с метками перечислены ниже. Во всех описаниях $L$ обозначает любую корректную
метку.

\begin{itemize}
\item \texttt{L:} (то есть $L$, за которым следует двоеточие <<:>>)~--- определяет положение метки $L$ в
программе. Все объявленные метки должны быть уникальными. Объявление метки
не оказывает влияния на одометр.
\item \texttt{jump L}~--- продолжить выполнение, в любом случае перейдя на строку с меткой $L$.
\item \texttt{border L}~--- продолжить выполнение путем перехода на строку с меткой $L$, если
одометр находится на границе, причем он ориентирован в сторону границы поля, то есть
инструкция move ничего не сделает. В противном случае выполнение программы
продолжается в обычном порядке и эта команда ничего не делает.
\item \texttt{pebble L}~--- продолжить выполнение путем перехода на строку с меткой $L$, если в
текущей клетке есть хотя бы один камень. В противном случае выполнение
программы продолжается в обычном порядке и эта команда ничего не делает.

\end{itemize}

\textbf{Пример 2}

В результате выполнения следующей программы одометр определяет местоположение
первого (самого западного) камня в строке $0$ и останавливается там. Если в строке $0$ нет
камней, то одометр останавливается на границе в конце строки. В этой программе
используется две метки: \texttt{leonardo} и \texttt{davinci}.

\begin{lstlisting}
right
leonardo:
pebble davinci \# найден камень
border davinci \# конец строки
move
jump leonardo
davinci:
halt
\end{lstlisting}

Сначала одометр поворачивается направо. Цикл начинается с объявления метки
\texttt{leonardo}: и заканчивается командой \texttt{jump leonardo}. В этом цикле одометр
проверяет наличие камня в текущей клетке или то, что он достиг границы. Если это не
так, то одометр выполняет команду \texttt{move} и перемещается из клетки $(0, j)$ в клетку $(0, j + 1)$. Здесь можно обойтись без команды \texttt{halt}, так как все равно программа закончит
выполнение после достижения последней строки.

\textbf{Условие}

Вы должны отправить программу на языке одометра, который описан выше. В каждой
подзадаче, которые определены ниже, требуется реализовать определенное поведение
одометра, при этом должны быть соблюдены два следующих ограничения.
\begin{itemize}
\item Размер программы~--- программа должна быть достаточно короткой. Размер
программы~--- это количество команд в ней. Объявления меток, комментарии и
пустые строки не учитываются при вычислении размера программы.
\item Количество операций~--- это программа должна быть достаточно быстрой.
Количество операций~--- это количество выполненных шагов: каждая отдельная
команда считается как один шаг, вне зависимости от того, имела ли эффект эта
команда или нет. Объявления меток, комментарии и пустые строки не считаются
шагом.
\end{itemize}

В примере $1$ размер программы равен $4$ и количество операций равно $4$. В примере $2$
размер программы равен $6$. В случае запуска программы с одним камнем в клетке $(0, 10)$
количество операций будет равно $43$: \texttt{right}, $10$ итерациям цикла, каждая итерация
занимает $4$ шага (\texttt{pebble davinci}; \texttt{border davinci}; \texttt{move}; \texttt{jump leonardo}), и
наконец, исполняются команды \texttt{pebble davinci} и \texttt{halt}.



\textbf{Детали реализации}

Вы должны отправить на проверку ровно один файл по каждой подзадаче, составленный
по вышеописанным правилам. Размер каждого файла не должен превосходить 5 мебибайт.
Для каждой подзадачи ваша программа для одометра будет протестирована на нескольких
наборах входных данных, и вы получите некоторую информацию о ресурсах,
использованных вашей программой. В том случае, если ваш код не является
синтаксически корректным, то вы получите информацию о виде синтаксической ошибки.

\textbf{Симулятор}

Для отладки вам будет предоставлен симулятор одометра, которому необходима
программа и входная сетка. Программа для одометра должна удовлетворять тому же
формату, который используется для посылок, который описан выше.

Сетка должна быть описана в следующем формате: каждая строка файла должна содержать
три числа, $R$, $C$, $P$, обозначающих клетку в строке $R$ и столбце $C$, содержащую $P$ камней.
Подразумевается, что все не упомянутые в файле клетки не содержат камней. Для примера
рассмотрим следующий файл:

\begin{lstlisting}
0 10 3
4 5 12
\end{lstlisting}

Сетка, описанная в этом файле, содержит $15$ камней: $3$ в ячейке $(0, 10)$ и $12$ в ячейке $(4, 5)$.

Вы можете запустить симулятор путем вызова программы simulator.py в папке с
задачей, передав ей файл с программой в качестве аргумента. Программа-симулятор будет
принимать следующие параметры командной строки:
\begin{itemize}
\item -h выведет вам краткий обзор всех возможных опций;
\item -g GRID_FILE загрузит описание сетки из файла GRID_FILE (по умолчанию
сетка пуста);
\item -s GRID_SIDE устанавливает размер сетки GRID_SIDE x GRID_SIDE
(значение по умолчанию равно 256, как указано в условии задачи); использование
меньших сеток может быть полезно для отладки программы;
\item -m STEPS ограничивает количество исполняемых симулятором шагов значением
STEPS;
\item -c переходит в режим компиляции. В режиме компиляции симулятор возвращает
такой же вывод, но вместо симуляции программы с использованием Python, он
генерирует небольшую программу на C. Это вызывает увеличение задержки на
старте, но позволяет получать результаты существенно быстрее. Мы советуем вам
использовать этот параметр когда предполагается, что ваша программа будет
выполнять больше чем примерно $10\,000\,000$ шагов.

\end{itemize}

По техническим причинам при вызове Judge и Custom интерпретатор настраивается несколько иначе. Вместо получения опций -g и -s он считывал их как два целых числа в дополнительной первой строке ввода.
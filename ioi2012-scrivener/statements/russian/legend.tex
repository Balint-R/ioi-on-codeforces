Некоторые люди говорят, что Леонардо был большим почитателем Иоганна Гутенберга, немецкого кузнеца, который изобрел подвижную (наборную) печать, и что он воздал должное, сконструировав машину, названную им наборщик-рак --- il gambero scrivano --- очень простое наборное устройство. Оно чем-то похоже на современную простою пишущую машинку и выполняет всего две команды: одна, чтобы напечатать следующий символ, и вторая, чтобы отменить несколько последних команд. Замечательным свойством наборщика-рака является исключительная мощность команды отмены, которая рассматривается сама по себе как команда и тоже может быть отменена. 

Вам необходимо реализовать программную модель наборщика-рака: она начинает работу с пустого текста, обрабатывает последовательность команд, передаваемых ей пользователем, и запросы относительно определенных позиций в текущем состоянии текста, как описано ниже.

\begin{itemize}
\item \t{Init()} --- вызывается один раз в начале выполнения, без аргументов. Может использоваться для инициализации структур данных. Эта операция никогда не отменяется.

\item \t{TypeLetter(L)} --- добавляет в конец текста один символ $L$ - маленькую букву из диапазона $a, \dots, z$.

\item \t{UndoCommands(U)} --- отменяет последние $U$ команд, где $U$ - положительное целое число.

\item \t{GetLetter(P)} --- возвращает символ - букву, находящуюся в позиции $P$ текущего текста, где $P$ - неотрицательное целое число. Первая буква текста имеет индекс $0$. (Этот запрос не является командой и поэтому игнорируется командой отмены.)
\end{itemize}

После начального вызова \t{Init()} другие процедуры могут вызываться ноль или более раз в любом порядке. Гарантируется, что $U$ не будет превышать количество ранее полученных команд и что $P$ будет меньше чем текущая длинна текста (количество букв в текущем тексте).

Вызов \t{UndoCommands(U)} отменяет предыдущие $U$ команд в обратном порядке. Если отменяемая команда - это \t{TypeLetter(L)}, то из конца текста удаляется буква $L$. Если отменяемая команда - это \t{UndoCommands(X)}, то для этого значения $X$ она заново применяет предыдущие $X$ команд в их оригинальном порядке.

Вы должны сдать только один файл с именем \t{scrivener.c}, \t{scrivener.cpp} или \t{scrivener.pas}. Эта программа должна реализовывать процедуры, описанные выше, с такими сигнатурами:

программы на C/C++:

\t{void Init();}

\t{void TypeLetter(char L);}

\t{void UndoCommands(int U);}

\t{char GetLetter(int P);}

программы на Pascal:

\t{procedure Init;}

\t{procedure TypeLetter(L : Char);}

\t{procedure UndoCommands(U : LongInt);}

\t{function GetLetter(P : LongInt) : Char;}

Эти подпрограммы должны вести себя как описано выше. Естественно вы имеете право реализовывать другие подпрограммы для внутреннего пользования. Ваши решения не должны взаимодействовать ни коим образом со стандартным вводом/выводом, и ни с каким другим файлом

Предоставленный проверяющий модуль читает ввод в таком формате:

\begin{itemize}
\item строка 1: общее количество команд и запросов на входе;
\item в каждой следующей строке:
\begin{itemize}
\item $T$, за которым следует пробел и маленькая буква для команды \t{TypeLetter};
\item $U$, за которым следует пробел и целое число для команды \t{UndoCommands};
\item $P$, за которым следует пробел и целое число для запроса \t{GetLetter}.
\end{itemize}
\end{itemize}

Предоставленный проверяющий модуль печатает возвращаемые \t{GetLetter} буквы, по
одной в строке.

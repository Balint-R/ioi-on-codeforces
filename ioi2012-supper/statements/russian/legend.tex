Леонардо был очень увлечен работой над Тайной Вечерей - его самой известной фреской. Одной из первоочередных его задач была - какие цвета красок использовать в течение рабочего дня. Ему нужны многие цвета красок, но количество мест на подставке для красок, которой пользовался художник, ограничено. Его помощник, кроме всего прочего, отвечал за подъем подставки для красок, чтобы доставлять их художнику, и за спуск подставки для красок, чтобы ставить краски обратно на соответствующую полку на полу.

В этой задаче вам нужно написать две отдельные программы для помощника. Первая получит инструкции Леонардо (последовательность красок, которые понадобятся Леонардо в течение дня), и создаст короткую версию плана, называемую подсказкой. В течение дня помощник не имеет доступа к списку запросов Леонардо, а только к той подсказке, которую сгенерировала ваша первая программа. Вторая программа получит вашу подсказку, и будет получать и обрабатывать запросы Леонардо в реальном времени (то есть по одному за раз). Эта программа должна понимать, что означает подсказка и использовать её для того, чтобы всегда делать оптимальные выборы. Далее это разъясняется более детально.

\bf{Перемещение красок между полкой на полу и подставкой для красок}

Мы будем рассматривать упрощенную модель. Предположим, что есть $N$ красок, пронумерованных от $0$ до $N-1$, и что каждый день Леонардо запрашивает у помощника новую краску ровно $N$ раз. Пусть $C$ - это последовательность красок, которые запросил Леонардо за день. Мы можем рассматривать $C$ как последовательность из $N$ чисел от $0$ до $N-1$ включительно. Заметьте, что некоторые из красок могут не встречаться в последовательности $C$, а некоторые - могут встречаться несколько раз.

Подставка для красок всегда заполнена и содержит ровно $K$ мест для $N$ красок, $K < N$. Изначально подставка для красок содержит краски от $0$ до $K-1$ включительно.

Помощник обрабатывает запросы Леонардо по одному. Если краска, о которой попросил Леонардо, уже установлена в подставку для красок, то помощник может отдохнуть. В противном случае, ему нужно взять на полке запрошенную художником краску и поставить ее на подставку для красок. Поскольку на подставке для красок не существует свободного места для новой краски, помощник должен выбрать на подставке одну из красок и переставить ее обратно на полку.

\bf{Оптимальная стратегия Леонардо}

Помощник хочет отдыхать как можно больше раз. Количество запросов, во время которых помощник может отдыхать, зависит от действий помощника. Точнее, каждый раз, когда помощник убирает краску с подставки, различные варианты выбора краски могут приводить к различным результатам в будущем. Леонардо объяснил ему, как он может добиться своей цели, зная последовательность запросов $C$. Наилучший выбор для краски, которую нужно убрать с подставки, можно узнать на основании того, какие краски сейчас находятся на подставке и какие запросы будут сделаны. Краску нужно выбрать из тех, которые находятся на подставке согласно следующим правилам:

\begin{itemize}

\item Если на подставке есть краска, которая больше не потребуется, то помощник должен забрать такую краску с подставки.

\item В противном случае, с подставки надо убрать ту краску, которая будет использована как можно позже, то есть для каждой краски на подставке мы находим первое будущее использование. Краска, которую мы переместим на полку должна быть той, которая потребуется последней.

\end{itemize}

Можно доказать, что при использовании стратегии, предложенной Леонардо, помощник будет отдыхать максимальное число раз.

\textit{См. пример 1}

\bf{Стратегия помощника, когда его память ограничена}

Утром помощник попросил Леонардо записать последовательность запросов $C$ на листе бумаги, чтобы найти оптимальную стратегию и следовать ей. Но Леонардо хочет сохранить в секрете технику своей работы, поэтому он отказался отдать помощнику лист с записями. Он разрешил ему только прочитать запись последовательности $C$ и попытаться её запомнить.

К сожалению, у помощника плохая память. Он может запомнить не более $M$ бит информации. Из-за этого он не всегда может запомнить всю последовательность запросов целиком. Но помощник может с умом подойти к вычислению той последовательности битов, которую он запомнит. Мы будем называть эту последовательность последовательностью-подсказкой и будем обозначать её $A$.

\textit{См. пример 2}

\bf{Постановка задачи}

Требуется написать две различные программы на одном и том же языке программирования. Эти программы будут выполняться последовательно, без возможности их взаимодействия.

Первая программа будет использована помощником утром. Эта программа получит последовательность $C$ и должна вычислить последовательность-подсказку $A$.

Вторая программа будет использована помощником в течение дня. Это программа получит последовательность-подсказку $A$ и будет обрабатывать последовательность $C$ запросов Леонардо. Заметим, что элементы последовательности $C$ будут передаваться программе по одному, и каждый запрос должен быть обработан до получения следующего элемента.

Более строго, ваша первая программа должна реализовать процедуру \t{ComputeAdvice(C, N, K, M)}, которая получает в качестве аргументов массив $C$ из $N$ целых чисел (каждое в диапазоне $0, \dots, N-1$), число красок на подставке, и число бит $M$, которое помощник может запомнить. Программа должна вычислить последовательностьподсказку $A$, состоящую не более чем из $M$ бит. Программа должна передать последовательность $A$ системе, путем последовательного вызова следующей процедуры для каждого бита из $A$. 

\begin{itemize}

\item \t{WriteAdvice(B)} --- добавить в конец текущей последовательности-подсказки $A$ бит $B$. Вы можете вызвать эту процедуру не более, чем $M$ раз.

\end{itemize}

Во второй программе вам надо реализовать процедуру \t{Assist(A, N, K, R)}. Этой процедуре будут переданы последовательность-подсказка $A$, целые числа $N$ и $K$, описанные выше, и длина $R$ последовательности-подсказки $A$ в битах $(R \le M)$. В этой процедуре вы должны будете выполнить предложенную вами стратегию для помощника, используя следующие процедуры:

\begin{itemize}

\item \t{GetRequest()} --- возвращает следующую краску, запрошенную Леонардо. Никакая информация о будущих запросах не разглашается.

\item \t{PutBack(T)} --- перемещат краску $T$ с подставки обратно на полку. Вы можете вызвать эту процедуру только в том случае, если краска $T$ находится на подставке.

\end{itemize}

Ваша процедура \t{Assist} должна вызывать \t{GetRequest} ровно $N$ раз, каждый раз получая следующий по порядку запрос Леонардо. После каждого вызова \t{GetRequest}, если краска, которую запросил Леонардо, находится не на подставке для красок, то должна быть вызвана процедура \t{PutBack(T)} с выбранным вами $T$. В противном случае процедура \t{PutBack} вызываться не должна. Если это сделать не так как описано, то это будет расценено как ошибка и приведет к завершению работы вашей программы. Обратите внимание, что изначально на подставке стоят краски с номерами от $0$ до $K-1$.

Тест будет считаться успешно пройденным, если обе ваши процедуры выполнили все вышеописанные ограничения и количество вызовов процедуры \t{PutBack} в точности равно тому, которое совершается при использовании оптимальной стратегии, описанной Леонардо. Если есть несколько оптимальных стратегий, которые совершают такое же количество вызовов процедуры \t{PutBack}, то можно выбрать любую из них. То есть не требуется в точности следовать стратегии Леонардо, если есть другая оптимальная стратегия.

\textit{См. пример 3}

\bf{Детали реализации }

Необходимо послать на проверку ровно два файла, содержащих описанные выше процедуры. 

Первый файл должен называться \t{advisor.c} или \t{advisor.cpp}. Файл должен содержать реализацию процедуры \t{ComputeAdvice}, как описано выше, и вызывать процедуру \t{WriteAdvice}. Второй файл должен называться \t{assistant.c} или \t{assistant.cpp}. Файл должен содержать реализацию процедуры \t{Assist}, как описано выше, и вызывать процедуры \t{GetRequest} и \t{PutBack}. 

Прототипы всех необходимых процедур представлены ниже. 

\t{void ComputeAdvice(int *C, int N, int K, int M);}

\t{void WriteAdvice(unsigned char a);}

\t{void Assist(unsigned char *A, int N, int K, int R);}

\t{void PutBack(int T);}

\t{int GetRequest();}

Эти процедуры должны вести себя так, как описано выше. Конечно, можно реализовывать любые другие процедуры для внутреннего использования. Для программ на \t{C/C++} ваши внутренние процедуры должны быть объявлены как статические (\t{static}), так как они будут слинкованы в один файл. Другим решением будет избегать одинаковых названий процедур в разных файлах. Нельзя взаимодействовать с файлами и со стандартным вводом/выводом. 

\bf{Пример проверяющего модуля (grader)}

Предоставленый пример проверяющего модуля принимает данные в следующем формате:

\begin{itemize}
\item Строка 1: $N, K, M$;
\item Строки со 2-й по (N+1)-ю: $C[i]$.
\end{itemize}

Проверяющий модуль сначала вызовет процедуру \t{ComputeAdvice}. В результате этого будет сгенерирован файл \t{advice.txt}, содержащий биты последовательности подсказки, разделенные пробелом. Файл будет завершен цифрой \t{2}.

После этого будет запущена процедура \t{Assist}, в результате запуска которой будет сгенерирован вывод, каждая строка которого будет либо в форме \t{"R [number]"}, либо в форме \t{"P [number]"}. Строки первого типа будут обозначать вызов процедуры \t{GetRequest()} и полученные ответы. Строки второго типа будут обозначать вызовы процедуры \t{PutBack} и краски, которые забираются с подставки. Вывод будет завершен строкой вида \t{"E"}.

Необходимо обратите внимание, что с использованием официального проверяющего модуля время выполнения программы может отличаться от времени работы программы на локальном компьютере. Это различие не будет значительным. Тем не менее, можно использовать веб-интерфейс для того, чтобы убедиться, что решение укладывается в ограничение по времени.

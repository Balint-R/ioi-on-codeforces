\bf{Пример 1}

Пусть $N = 4$, то есть у нас есть 4 краски, пронумерованных от $0$ до $3$, и 4 запроса. Пусть последовательность запросов $C = (2, 0, 3, 0).$ Пусть $K = 2$. Это значит, что у Леонардо есть подставка для красок, которая вмещает две краски. Как было указано выше, подставка для красок изначально содержит краски $0$ и $1$. Мы будем записывать набор красок, которые есть на подставке, как $[0, 1]$. Один возможный способ, по которому помощник может обрабатывать запросы художника, следует ниже.

Первая запрошенная краска (номер $2$) отсутствует на подставке для красок. Помощник устанавливает её туда, решая убрать краску $1$ с подставки. Текущий набор красок на доске для красок такой: $[0, 2]$.

\begin{itemize}

\item Следующая запрошенная краска (номер $0$) уже имеется на подставке для красок, так что помощник может отдохнуть.

\item Для того, чтобы обработать третий запрос (краска номер $3$), помощник убирает краску $0$. Теперь на подставке для красок находятся краски $[3, 2]$.

\item Наконец, последнюю запрошенную краску (номер $0$) нужно забрать с полки для установки на подставку для красок. Помощник решает для этого убрать с подставки краску с номером $2$, и подставка теперь содержит набор красок $[3, 0]$.

\end{itemize}

Заметьте, что в приведенном выше примере помощник не придерживался оптимальной стратегии Леонардо. Оптимальным было бы убрать краску с номером $2$ при выполнение третьего запроса, при этом помощник мог бы отдохнуть на последнем шаге. 

\bf{Пример 2}

Утром помощник берет записку Леонардо с последовательностью $C$, читает эту последовательность и делает все необходимые выборы. Например, он может отслеживать состояния подставки для красок после каждого из запросов. Так, используя (неоптимальную) стратегию из примера $1$, последовательность состояний подставки для красок будет $[0, 2]$, $[0, 2]$, $[3, 2]$, $[3, 0]$. Заметим, что он знает, что начальное состояние подставки было $[0, 1]$.

Допустим, что $M = 16$, то есть помощник может запомнить 16 бит информации. Так как $N = 4$, можно запоминать номер краски, используя 2 бита. По этой причине, 16 бит достаточно, чтобы запомнить описанную выше последовательность состояний подставки для красок. Таким образом, помощник вычисляет следующую последовательность $A = (0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0)$.

В течение дня, помощник сможет, расшифровывая последовательность-подсказку, делать свои выборы.

Очевидно, что при $M = 16$ помощник может просто запомнить последовательность $C$ вместо этого, используя только 8 бит из доступных 16. Этим примером мы хотели показать, что он может действовать не так, как описано выше, не выдавая каких-либо хороших решений.

\bf{Пример 3}

Снова рассмотрим \bf{пример 2}. Предположим, что ваша процедура \t{ComputeAdvice} вернула $A = (0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0)$. Для взаимодействия с системой вы должны сделать следующую последовательность вызовов процедуры \t{WriteAdvice}: 

\t{WriteAdvice(0)}, \t{WriteAdvice(0)}, \t{WriteAdvice(1)}, \t{WriteAdvice(0)}, \t{WriteAdvice(0)}, \t{WriteAdvice(0)}, \t{WriteAdvice(1)}, \t{WriteAdvice(0)}, \t{WriteAdvice(1)}, \t{WriteAdvice(1)}, \t{WriteAdvice(1)}, \t{WriteAdvice(0)}, \t{WriteAdvice(1)}, \t{WriteAdvice(1)}, \t{WriteAdvice(0)}, \t{WriteAdvice(0)}

Ваша вторая процедура \t{Assist} при запуске получит вышеописанную последовательность $A$ и значения $N = 4, K = 2$ и $R = 16$. Процедура \t{Assist} должна сделать ровно $N = 4$ вызовов процедуры \t{GetRequest}. Кроме этого, вам нужно вызвать процедуру \t{PutBack(T)} после некоторых вызовов процедуры \t{GetRequest}

Таблица ниже иллюстрирует последовательность вызовов, которые соответствуют неоптимальным выборам помощника из \bf{примера 1}. Прочерк обозначает отсутствие вызова процедуры \t{PutBack}

\begin{tabular}{cc}
\bf{\t{GetRequest()}}&\bf{Действие}\\
2 &PutBack(1)\\
0 &-\\
3 &PutBack(0)\\
0 &PutBack(2)\\
\end{tabular}



Ilshat is a software engineer working on efficient data structures. One day he invented a new data structure. 
This data structure can store a set of \textbf{non-negative} $n$-bit integers, where $n$ is a power of two. 
That is, $n = 2^b$ for some non-negative integer $b$.

The data structure is initially empty. A program using the data structure has to follow the following rules:

\begin{itemize}
\item The program can add elements that are $n$-bit integers into the data structure, one at a time, by using the 
function \texttt{add\_element(x)}. If the program tries to add an element that is already present in the data structure,
nothing happens.
\item After adding the last element the program should call the function \texttt{compile\_set()} exactly once.
\item Finally, the program may call the function \texttt{check\_element(x)} to check whether the element $x$ is present
in the data structure. This function may be used multiple times.
\end{itemize}

When Ilshat first implemented this data structure, he made a bug in the function \texttt{compile\_set()}. The bug
reorders the binary digits of each element in the set in the same manner. Ilshat wants you to find the exact reordering
of digits caused by the bug.

Formally, consider a sequence $p_0, \ldots, p_{n - 1}$ in which every number from $0$ to $n - 1$ appears exactly once. 
We call such a sequence a \textbf{permutation}. Consider an element of the set, whose digits in binary are $a_0, \ldots, a_{n - 1}$ 
(with $a_0$ being the most significant bit). When the function \texttt{compile\_set()} is called, this element is replaced
by the element $a_{p_0}, a_{p_1}, \ldots, a_{p_{n - 1}}$. 

The same permutation $p$ is used to reorder the digits of every element. Any permutation is possible, including the possibility
that $p_i = i$ for each $0 \le i \le n - 1$.

For example, suppose that $n = 4$, $p = [2, 1, 3, 0]$, and you have inserted into the set integers whose binary representations
are \texttt{0000}, \texttt{1100} and \texttt{0111}. Calling the function \texttt{compile\_set} changes these elements to
\texttt{0000}, \texttt{0101} and \texttt{1110}, respectively.

Your task is to write a program that finds the permutation $p$ by interacting with the data structure. It should 
(in the following order):

\begin{enumerate}
\item choose a set of $n$-bit integers,
\item insert those integers into the data structure,
\item call the function \texttt{compile\_set} to trigger the bug,
\item check the presence of some elements in the modified set,
\item use that information to determine and return the permutation $p$.
\end{enumerate}

Note that your program may call the function \texttt{compile\_set} only once.

In addition, there is a limit on the number of times your program calls the library functions. Namely, it may
\begin{itemize}
\item call \texttt{add\_element} at most $w$ times ($w$ is for ``writes''),
\item call \texttt{check\_element} at most $r$ times ($r$ is for ``reads'').
\end{itemize}

\textbf{Implementation details}

You should implement one function (method):

\begin{itemize}\item \texttt{int[] restore\_permutation(int n, int w, int r)}
\begin{itemize}
	\item \texttt{n}: the number of bits in the binary representation of each element of the set (and also the length of $p$).
	\item \texttt{w}: the maximum number of \texttt{add\_element} operations your program can perform.
	\item \texttt{r}: the maximum number of \texttt{check\_element} operations your program can perform.
	\item the function should return the restored permutation $p$.
\end{itemize}
\end{itemize}


\textbf{Library functions}

In order to interact with the data structure, your program should use the following three functions (methods):

\begin{itemize}
\item \texttt{void add\_element(string x)}

	This function adds the element described by \texttt{x} to the set.
\begin{itemize}
	\item \texttt{x}: a string of \texttt{`0'} and \texttt{`1'} characters giving the binary representation of an integer
    that should be added to the set. The length of \texttt{x} must be $n$.
\end{itemize}
\end{itemize}

\begin{itemize}
\item \texttt{void compile\_set()}

This function must be called exactly once. Your program cannot call \texttt{add\_element()} after this call.
    Your program cannot call \texttt{check\_element()} before this call.
\end{itemize}

\begin{itemize}
\item \texttt{boolean check\_element(string x)}

This function checks whether the element \texttt{x} is in the modified set.

\begin{itemize}
	\item \texttt{x}: a string of \texttt{`0'} and \texttt{`1'} characters giving the binary representation of
    the element that should be checked. The length of \texttt{x} must be $n$.
	\item returns \texttt{true} if element \texttt{x} is in the modified set, and \texttt{false} otherwise.
\end{itemize}
\end{itemize}

Note that if your program violates any of the above restrictions, its grading outcome will be ``Wrong Answer''.

For all the strings, the first character gives the most significant bit of the corresponding integer.

The grader fixes the permutation $p$ before the function \texttt{restore\_permutation} is called.

Please use the provided template files for details of implementation in your programming language.

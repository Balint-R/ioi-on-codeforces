Ильшат работает программистом и занимается разработкой высокопроизводительных структур данных. Однажды он изобрел новую структуру данных. Эта структура данных хранит множество неотрицательных
$n$-битных целых чисел, где $n$~--- степень числа 2. А именно, $n = 2^b$ для некоторого неотрицательного целого числа $b$.

Изначально структура данных пуста. Программа, использующая структуру данных, должна соблюдать следующие правила:

\begin{itemize}
\item Программа может добавлять в структуру данных элементы, которые являются $n$-битными целыми числами, используя функцию \texttt{add\_element(x)}. Если программа пытается добавить в структуру данных число, которое в ней уже есть, то ничего не происходит.
\item После добавления элементов программа должна вызывать функцию \texttt{compile\_set()} ровно один раз.
\item После этого программа может вызывать функцию \texttt{check\_element(x)}, чтобы проверить, есть ли элемент $x$ в структуре данных. Эту функцию можно вызывать несколько раз.
\end{itemize}

Когда Ильшат в первый раз реализовал эту структуру данных, он сделал баг в функции \texttt{compile\_set()}. В результате бага после вызова этой функции двоичные цифры каждого элемента в структуре данных оказываются переставлены, причем цифры всех элементов переставляются одним и тем же образом. Ильшат хочет выяснить, как именно переставляются цифры.

Формально, рассмотрим последовательность $p_0, \ldots, p_{n - 1}$, в которой каждое число от $0$ до $n - 1$ встречается ровно один раз. Будем называть такую последовательность перестановкой. Рассмотрим элемент в структуре данных, двоичная запись которого состоит из цифр $a_0, \ldots, a_{n - 1}$ (здесь $a_0$~--- старший бит). Когда вызывается функция \texttt{compile\_set()}, этот элемент заменяется на элемент с двоичной записью $a_{p_0}, a_{p_1}, \ldots, a_{p_{n - 1}}$. 

Одна и та же перестановка $p$ используется для изменения порядка двоичных цифр каждого из элементов. Перестановка может быть любой, в частности тождественной, то есть возможно, что $p_i = i$ для всех $0 \le i \le n - 1$.

Например, пусть $n = 4$, $p = [2, 1, 3, 0]$, и программа добавила в структуру данных элементы с двоичными представлениями \texttt{0000}, \texttt{1100} и \texttt{0111}. Вызов функции \texttt{compile\_set()} заменит эти элементы на элементы \texttt{0000}, \texttt{0101} и \texttt{1110}, соответственно.

Требуется написать программу, которая находит перестановку $p$, взаимодействуя со структурой данных. Она должна выполнить по порядку следующие действия:

\begin{enumerate}
\item выбрать множество $n$-битных неотрицательных целых чисел,
\item добавить эти элементы в структуру данных,
\item вызвать функцию \texttt{compile\_set()}, чтобы активировать баг,
\item проверить наличие некоторых элементов в получившейся структуре
данных,
\item используя полученную информацию, определить и вернуть перестановку $p$.
\end{enumerate}

Обратите внимание, что разрешается вызвать функцию \texttt{compile\_set} ровно один раз.

Также существуют ограничения на количество запросов к структуре данных, которые разрешается сделать вашей программе. А именно, она может:
\begin{itemize}
\item вызвать функцию \texttt{add\_element} не более $w$ раз ($w$ от английского слова "write"),
\item вызвать \texttt{check\_element} не более $r$ раз ($r$ от английского слова "read").
\end{itemize}

\textbf{Детали реализации}

Требуется реализовать одну функцию (метод):

\begin{itemize}\item \texttt{int[] restore\_permutation(int n, int w, int r)}
\begin{itemize}
	\item \texttt{n}: число бит в двоичной записи каждого элемента в структуре данных (а также длина искомой перестановки $p$).
	\item \texttt{w}: максимальное количество вызовов функции \texttt{add\_element}, которое разрешается сделать.
	\item \texttt{r}: максимальное количество вызовов функции \texttt{check\_element}, которое разрешается сделать.
	\item функция должна вернуть найденную перестановку $p$.
\end{itemize}
\end{itemize}

\textbf{Функции библиотеки}

Для взаимодействия со структурой данных, ваша программа должна использовать следующие три функции (метода):

\begin{itemize}
\item \texttt{void add\_element(string x)}

Добавить элемент, заданный строкой \texttt{x}, в структуру данных.
\begin{itemize}
	\item \texttt{x}: строка из \texttt{'0'} и \texttt{'1'} задающая двоичное представление числа, который необходимо добавить в структуру данных. Длина строки \texttt{x} должна быть равна $n$.
\end{itemize}
\end{itemize}

\begin{itemize}
\item \texttt{void compile\_set()}

Эта функция должна быть вызвана ровно один раз. Ваша программа не может вызывать функцию \texttt{add\_element()} после этого вызова. Ваша программа не может вызывать \texttt{check\_element()} до этого вызова.
\end{itemize}

\begin{itemize}
\item \texttt{boolean check\_element(string x)}

Эта функция проверяет, есть ли элемент, заданный строкой \texttt{x} в полученной после вызова \texttt{compile\_set()} структуре данных.
\begin{itemize}
	\item \texttt{x}: строка из \texttt{'0'} и \texttt{'1'} задающая двоичное представление числа, наличие которого в структуре данных необходимо проверить. Длина строки \texttt{x} должна быть равна $n$.
	\item возвращает \texttt{true} если элемент \texttt{x} есть в полученной структуре данных, либо \texttt{false} в противном случае.
\end{itemize}
\end{itemize}

Обратите внимание, что если ваша программа нарушит одно из перечисленных ограничений, то результат проверки будет "Wrong Answer".

Для всех строк, задающих двоичные числа, первый символ соответствует старшему биту числа.

Используйте приведенный шаблон решения для получения деталей реализации на выбранном вами языке программирования.

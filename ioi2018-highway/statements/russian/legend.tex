Города в Японии соединены дорожной сетью. Сеть состоит из $N$ городов и $M$ дорог. Каждая дорога соединяет пару различных городов. Никакие две дороги не соединяют одну и ту же пару городов. Города пронумерованы от $0$ до $N-1,$ а дороги пронумерованы от $0$ до $M-1.$ По каждой дороге можно проехать в любом из двух направлений. Из любого города в любой другой можно добраться по дорогам. 

За проезд по каждой дороге необходимо заплатить пошлину. Пошлина на каждой дороге зависит от \bf{загруженности} этой дороги. Загруженность дороги может быть \bf{слабой} либо \bf{сильной}. Пошлина для слабо загруженной дороги составляет $A$ йен (японских денежных единиц), а для сильно загруженной дороги --- $B$ йен. Гарантируется, что $A < B.$ Обратите внимание, что значения $A$ и $B$ вам известны. 

У вас есть устройство, которое по заданной вами информации о загруженности всех дорог вычисляет наименьшую суммарную пошлину, которую необходимо заплатить для проезда между городами $S$ и $T (S \neq T)$ при такой загруженности дорог. 

Ваше устройство еще находится в стадии разработки. Значения $S$ и $T$ зафиксированы внутри устройства и вам неизвестны. Вы хотите найти $S$ и $T.$ Для этого вы собираетесь воспользоваться устройством в нескольких сценариях загруженности дорог и, пользуясь полученными из устройства значениями пошлин для проезда, определить $S$ и $T.$ Поскольку управлять устройством сложно, вы хотите воспользоваться им не слишком много раз.

\bf{Детали реализации}

Вам требуется реализовать следующую процедуру:

\t{find_pair(int N, int[] U, int[] V, int A, int B)}

\begin{itemize}
\item $N$: количество городов.
\item $U$ и $V$: массивы длины $M,$ где $M$ --- количество дорог в сети. Для каждого $i: 0 \le i \le M-1,$ дорога $i$  соединяет города $U[i]$ и $V[i].$ 
\item $A$: пошлина за проезд по слабо загруженной дороге. 
\item $B$: пошлина за проезд по сильно загруженной дороге.
\item Процедура будет вызвана ровно один раз для каждого теста. 
\item Обратите внимание, что $M$ --- это длина массивов, способ получения длины массива описан в памятке о деталях реализации.
\end{itemize}

\t{int64 ask(int[] w)}

\begin{itemize}
\item Длина $w$ должна быть равна $M.$ Массив $w$ описывает сценарий загруженности дорог.
\item Для каждого $i: 0 \le i \le M-1, w[i]$ задает загруженность дороги $i.$ Значение $w[i]$ должно быть равно $0$ или $1.$
\begin{itemize}
\item $w[i] = 0$ означает, что дорога $i$ слабо загружена.
\item $w[i] = 1$ означает, что дорога $i$ сильно загружена.
\end{itemize}
\item Функция возвращает наименьшую суммарную пошлину, которую необходимо заплатить для проезда между городами $S$ и $T$ при условиях загруженности, заданных $w.$
\item Функция может быть вызвана не более $100$ раз (для каждого теста).
\end{itemize}
\bf{}
Чтобы сообщить ответ, \t{find_pair} должна вызвать следующую процедуру:

\t{answer(int s, int t)}

\begin{itemize}
\item \t{s} и \t{t} должны содержать значения $S$ и $T$ (порядок не важен).
\item Процедура должна быть вызвана ровно один раз.
\end{itemize}

Если какие-то из описанных выше требований не выполнены, ваша программа получает вердикт \bf{Wrong Answer}. Иначе программа получает вердикт \bf{Accepted}, и полученные баллы вычисляются в зависимости от количества вызовов \t{ask} (см. раздел Подзадачи).

\bf{Ограничения}

\begin{itemize}
\item $2 \le N \le 90\,000$
\item $1 \le M \le 130\,000$
\item $1 \le A < B \le 1\,000\,000\,000$
\item Для каждого $i: 0 \le i M-1$
\begin{itemize}
\item $0 \le U[i] \le N-1$
\item $0 \le V[i] \le N-1$
\item $U[i] \neq V[i]$
\end{itemize}
\item $(U[i], V[i]) \neq (U[j], V[j])$ и $(U[i], V[j]) \neq (V[j], U[j])$ for all $i,j: 0 \le i < j \le M-1$
\item Из каждого города можно добраться в любой другой по дорогам.
\item $0 \le S \le N-1$
\item $0 \le T \le N-1$
\item $S \neq T$
\end{itemize}

В этой задаче проверяющий модуль НЕ ЯВЛЯЕТСЯ адаптивным. Это означает, что  $S$ и $T$  зафиксированы в начале запуска модуля и не зависят от запросов, сделанных вашим решение

\bf{Пример проверяющего модуля}

Пример проверяющего модуля читает входные данные в следующем формате:

\begin{tabular}{lllll}
строка&$1$&:&$N$ $M$ $A$ $B$ $S$ $T$&\\
строка&$2+i$&:&$U[i]$ $V[i]$&$(0 \le i \le M-1)$ \\
\end{tabular}

Если ваша программа оценена как \bf{Accepted}, пример тестирующего модуля печатает \t{Accepted: q}, где $q$ --- число вызовов \t{ask}.

Если ваша программа оценена как \bf{Wrong Answer}, он печатает \t{Wrong Answer: MSG}, где \t{MSG} --- одно из следующих предложений:

\begin{itemize}
\item \t{answered not exactly once}: процедура \t{answer} была вызвана не в точности один раз.
\item \t{w is invalid}: длина $w,$ переданного в \t{ask}, не равна $M,$ либо для некоторого $i : 0 \le i \le M-1, w[i]$ не равно ни $0,$ ни $1.$
\item \t{more than 100 calls to ask}: функция \t{ask} вызвана более $100$ раз.
\item \t{{s, t} is wrong}: процедура \t{answer} вызвана с некорректной парой $s$ и $t.$
\end{itemize}


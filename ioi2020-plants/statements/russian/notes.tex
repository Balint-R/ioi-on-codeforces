\textbf{Пример 1}

Рассмотрим следующий вызов:

\t{init(3, [0, 1, 1, 2])}

Пусть проверяющий модуль затем делает вызов \t{compare\_plants(0, 2)}. Поскольку $r[0] = 0$, можно сделать вывод, что растение $2$ не выше растения $0$. Следовательно, функция должна вернуть $1$.

Пусть проверяющий модуль затем делает вызов \t{compare\_plants(1, 2)}. Для всех возможных конфигураций растений, которым соответствует заданный массив, растение $1$ ниже растения $2$.  Поэтому функция должна вернуть $-1$.

\textbf{Пример 2}

Рассмотрим следующий вызов:

\t{init(2, [0, 1, 0, 1])}

Пусть проверяющий модуль затем делает вызов \t{compare\_plants(0, 3)}. Поскольку $r[3] = 1$, известно, что растение $0$ выше растения $3$. Следовательно, функция должна вернуть $1$.

Пусть проверяющий модуль затем делает вызов \t{compare\_plants(1, 3)}. Рассмотрим две конфигурации $[3,1,4,2]$ и $[3,2,4,1]$, для каждой из них Хазель запишет одни и те же значения. Поскольку растение $1$ в одной конфигурации ниже растения $3$, а в другой~--- выше, растения $3$, функция должна вернуть $0$.


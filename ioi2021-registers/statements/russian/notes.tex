\textbf{Пример 1}

Пусть $s = 0$, $n = 2$, $k = 1$, $q = 1000$. Входные данные состоят из двух чисел $a[0]$ и $a[1]$, каждое из которых состоит из $k=1$ бит. Перед выполнением программы $r[0][0] = a[0]$ и $r[0][1] = a[1]$. Все остальные биты выставлены в $0$. После выполнения всех инструкций программы должно выполняться $c[0]=r[0][0] = \min(a[0], a[1])$, что обозначает наименьшее среди чисел $a[0]$ и $a[1]$.

Существует 4 возможных варианта входных данных:
\begin{itemize}
\item вариант $1$: $a[0]=0, a[1]=0$
\item вариант $2$: $a[0]=0, a[1]=1$
\item вариант $3$: $a[0]=1, a[1]=0$
\item вариант $4$: $a[0]=1, a[1]=1$
\end{itemize}

Заметим, что для всех 4 случаев $\min(a[0], a[1])$ совпадает с побитовым И чисел $a[0]$ и $a[1]$. Таким образом, одна из возможных программ может содержать следующие 3 инструкции:
\begin{enumerate}
\item \texttt{append\_move(1, 0)}, которая копирует значение $r[0]$ в $r[1]$.
\item \texttt{append\_right(1, 1, 1)}, которая рассматривает биты $r[1]$, сдвигает их вправо на $1$ бит, и записывает результат в $r[1]$. Так как каждое из чисел состоит из $1$-го бита, в результате этой операции $r[1][0]$ совпадает с $a[1]$.
\item \texttt{append\_and(0, 0, 1)}, которая вычисляет побитовое И чисел $r[0]$ и $r[1]$ и записывает результат в $r[0]$. После выполнения этой инструкции $r[0][0]$ будет содержать побитовое И значений $r[0][0]$ и $r[1][0]$, которое совпадает с побитовым И значений $a[0]$ и $a[1]$, как и требовалось.
\end{enumerate}


\textbf{Пример 2}

Пусть $s=1$, $n=2$, $k=1$, $q=1000$. Как и в предыдущем примере, существует лишь 4 варианта входных данных. Для каждого из этих 4 вариантов $\min(a[0], a[1])$ совпадает со значением побитового И значений $a[0]$ и $a[1]$, а $\max(a[0], a[1])$ совпадает с побитовым ИЛИ значений $a[0]$ и $a[1]$. Одна из допустимых программ может содержать следующие инструкции:
\begin{enumerate}
\item \texttt{append\_move(1,0)}
\item \texttt{append\_right(1,1,1)}
\item \texttt{append\_and(2,0,1)}
\item \texttt{append\_or(3,0,1)}
\item \texttt{append\_left(3,3,1)}
\item \texttt{append\_or(0,2,3)}
\end{enumerate}

После выполнения этих инструкций $c[0]=r[0][0]$ содержит $\min(a[0],a[1])$, а $c[1]=r[0][1]$ содержит $\max(a[0],a[1])$, что является достаточным для сортировки.